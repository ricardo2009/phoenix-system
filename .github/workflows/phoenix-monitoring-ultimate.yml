name: ğŸ“Š Phoenix Monitoring - Ultimate Observability Engine

on:
  schedule:
    # Continuous monitoring every 15 minutes
    - cron: '*/15 * * * *'
    # Daily comprehensive analysis at 6:00 AM UTC
    - cron: '0 6 * * *'
    # Weekly deep analysis on Sundays at 2:00 AM UTC
    - cron: '0 2 * * 0'
  push:
    branches: [main]
    paths:
      - 'monitoring/**'
      - '.github/workflows/phoenix-monitoring-ultimate.yml'
  workflow_dispatch:
    inputs:
      monitoring_scope:
        description: 'Monitoring Scope'
        required: true
        default: 'comprehensive'
        type: choice
        options:
          - comprehensive   # Full system monitoring
          - infrastructure  # Infrastructure only
          - applications    # Applications only
          - security        # Security monitoring
          - performance     # Performance monitoring
          - cost           # Cost analysis
          - compliance     # Compliance checking
      alert_level:
        description: 'Alert Sensitivity Level'
        required: true
        default: 'normal'
        type: choice
        options:
          - low            # Only critical alerts
          - normal         # Standard alerting
          - high           # Sensitive alerting
          - debug          # All events
      target_environments:
        description: 'Target Environments'
        required: true
        default: 'all'
        type: string
      enable_remediation:
        description: 'Enable Auto-Remediation'
        required: false
        default: true
        type: boolean
      generate_reports:
        description: 'Generate Detailed Reports'
        required: false
        default: true
        type: boolean

env:
  MONITORING_VERSION: '2.0'
  ALERT_TIMEOUT: 300
  REMEDIATION_TIMEOUT: 600
  REPORT_RETENTION_DAYS: 90
  
concurrency:
  group: phoenix-monitoring-${{ github.ref }}-${{ inputs.monitoring_scope || 'auto' }}
  cancel-in-progress: false

jobs:
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ğŸ§  MONITORING ORCHESTRATION ENGINE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  monitoring-orchestration:
    name: ğŸ§  Monitoring Orchestration Engine
    runs-on: ubuntu-latest
    timeout-minutes: 20
    outputs:
      # Dynamic Matrices
      monitoring-matrix: ${{ steps.monitoring-matrix.outputs.monitoring-matrix }}
      environment-matrix: ${{ steps.env-matrix.outputs.environment-matrix }}
      alert-matrix: ${{ steps.alert-matrix.outputs.alert-matrix }}
      remediation-matrix: ${{ steps.remediation-matrix.outputs.remediation-matrix }}
      
      # Configuration
      monitoring-scope: ${{ steps.config.outputs.monitoring-scope }}
      alert-level: ${{ steps.config.outputs.alert-level }}
      session-id: ${{ steps.session.outputs.session-id }}
      baseline-metrics: ${{ steps.baseline.outputs.baseline-metrics }}
      
    steps:
      - name: ğŸš€ Initialize Monitoring Engine
        run: |
          echo "ğŸ“Š Phoenix Ultimate Observability Engine v${{ env.MONITORING_VERSION }}"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ğŸ¯ Event: ${{ github.event_name }}"
          echo "â° Schedule: ${{ github.event.schedule || 'Manual' }}"
          echo "ğŸ” Scope: ${{ inputs.monitoring_scope || 'comprehensive' }}"
          echo "ğŸš¨ Alert Level: ${{ inputs.alert_level || 'normal' }}"
          echo "ğŸ”§ Auto-Remediation: ${{ inputs.enable_remediation || 'true' }}"
          
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ğŸ“Š Generate Session Metadata
        id: session
        run: |
          SESSION_ID="phoenix-mon-$(date +%Y%m%d-%H%M%S)-${{ github.run_number }}"
          echo "session-id=$SESSION_ID" >> $GITHUB_OUTPUT
          echo "ğŸ†” Monitoring Session: $SESSION_ID"
          
      - name: âš™ï¸ Configuration Engine
        id: config
        run: |
          SCOPE="${{ inputs.monitoring_scope || 'comprehensive' }}"
          ALERT_LEVEL="${{ inputs.alert_level || 'normal' }}"
          
          # Determine monitoring scope based on trigger
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            case "${{ github.event.schedule }}" in
              "*/15 * * * *")
                SCOPE="performance"
                ALERT_LEVEL="normal"
                ;;
              "0 6 * * *")
                SCOPE="comprehensive"
                ALERT_LEVEL="normal"
                ;;
              "0 2 * * 0")
                SCOPE="comprehensive"
                ALERT_LEVEL="debug"
                ;;
            esac
          fi
          
          echo "monitoring-scope=$SCOPE" >> $GITHUB_OUTPUT
          echo "alert-level=$ALERT_LEVEL" >> $GITHUB_OUTPUT
          
          echo "âš™ï¸ Configuration:"
          echo "  Scope: $SCOPE"
          echo "  Alert Level: $ALERT_LEVEL"
          
      - name: ğŸŒ Environment Matrix Generation
        id: env-matrix
        run: |
          TARGET_ENVS="${{ inputs.target_environments || 'all' }}"
          
          if [[ "$TARGET_ENVS" == "all" ]]; then
            ENVIRONMENTS='["dev", "staging", "prod"]'
          else
            IFS=',' read -ra ENV_ARRAY <<< "$TARGET_ENVS"
            ENVIRONMENTS=$(printf '%s\n' "${ENV_ARRAY[@]}" | jq -R . | jq -s .)
          fi
          
          echo "environment-matrix=$ENVIRONMENTS" >> $GITHUB_OUTPUT
          echo "ğŸŒ Environments: $ENVIRONMENTS"
          
      - name: ğŸ“Š Monitoring Matrix Generation
        id: monitoring-matrix
        run: |
          SCOPE="${{ steps.config.outputs.monitoring-scope }}"
          
          # Base monitoring matrix
          MONITORING_MATRIX=$(cat << 'EOF'
          [
            {
              "category": "infrastructure",
              "type": "health",
              "priority": 1,
              "interval": 300,
              "timeout": 120,
              "critical": true,
              "metrics": ["cpu", "memory", "disk", "network"],
              "thresholds": {
                "cpu": 80,
                "memory": 85,
                "disk": 90,
                "network": 95
              }
            },
            {
              "category": "infrastructure",
              "type": "availability",
              "priority": 1,
              "interval": 180,
              "timeout": 60,
              "critical": true,
              "metrics": ["uptime", "response_time", "error_rate"],
              "thresholds": {
                "uptime": 99.9,
                "response_time": 2000,
                "error_rate": 1
              }
            },
            {
              "category": "applications",
              "type": "performance",
              "priority": 2,
              "interval": 600,
              "timeout": 180,
              "critical": false,
              "metrics": ["throughput", "latency", "concurrent_users"],
              "thresholds": {
                "throughput": 1000,
                "latency": 500,
                "concurrent_users": 100
              }
            },
            {
              "category": "applications",
              "type": "functionality",
              "priority": 2,
              "interval": 900,
              "timeout": 300,
              "critical": true,
              "metrics": ["api_success_rate", "agent_response_time", "integration_health"],
              "thresholds": {
                "api_success_rate": 99,
                "agent_response_time": 3000,
                "integration_health": 95
              }
            },
            {
              "category": "security",
              "type": "threats",
              "priority": 1,
              "interval": 300,
              "timeout": 120,
              "critical": true,
              "metrics": ["failed_logins", "suspicious_activity", "vulnerability_scan"],
              "thresholds": {
                "failed_logins": 10,
                "suspicious_activity": 5,
                "vulnerability_scan": 0
              }
            },
            {
              "category": "security",
              "type": "compliance",
              "priority": 3,
              "interval": 3600,
              "timeout": 600,
              "critical": false,
              "metrics": ["policy_violations", "access_reviews", "encryption_status"],
              "thresholds": {
                "policy_violations": 0,
                "access_reviews": 100,
                "encryption_status": 100
              }
            },
            {
              "category": "cost",
              "type": "optimization",
              "priority": 3,
              "interval": 3600,
              "timeout": 300,
              "critical": false,
              "metrics": ["daily_spend", "resource_utilization", "waste_detection"],
              "thresholds": {
                "daily_spend": 500,
                "resource_utilization": 70,
                "waste_detection": 10
              }
            },
            {
              "category": "cost",
              "type": "budgets",
              "priority": 2,
              "interval": 1800,
              "timeout": 180,
              "critical": true,
              "metrics": ["budget_consumption", "forecast_accuracy", "anomaly_detection"],
              "thresholds": {
                "budget_consumption": 80,
                "forecast_accuracy": 90,
                "anomaly_detection": 20
              }
            },
            {
              "category": "business",
              "type": "kpis",
              "priority": 2,
              "interval": 1800,
              "timeout": 240,
              "critical": false,
              "metrics": ["user_satisfaction", "conversion_rate", "agent_effectiveness"],
              "thresholds": {
                "user_satisfaction": 85,
                "conversion_rate": 15,
                "agent_effectiveness": 90
              }
            },
            {
              "category": "business",
              "type": "sla",
              "priority": 1,
              "interval": 600,
              "timeout": 120,
              "critical": true,
              "metrics": ["availability_sla", "performance_sla", "support_sla"],
              "thresholds": {
                "availability_sla": 99.9,
                "performance_sla": 95,
                "support_sla": 90
              }
            }
          ]
          EOF
          )
          
          # Filter based on scope
          case "$SCOPE" in
            "infrastructure")
              MONITORING_MATRIX=$(echo "$MONITORING_MATRIX" | jq '[.[] | select(.category == "infrastructure")]')
              ;;
            "applications")
              MONITORING_MATRIX=$(echo "$MONITORING_MATRIX" | jq '[.[] | select(.category == "applications")]')
              ;;
            "security")
              MONITORING_MATRIX=$(echo "$MONITORING_MATRIX" | jq '[.[] | select(.category == "security")]')
              ;;
            "performance")
              MONITORING_MATRIX=$(echo "$MONITORING_MATRIX" | jq '[.[] | select(.type == "performance" or .type == "health")]')
              ;;
            "cost")
              MONITORING_MATRIX=$(echo "$MONITORING_MATRIX" | jq '[.[] | select(.category == "cost")]')
              ;;
            "compliance")
              MONITORING_MATRIX=$(echo "$MONITORING_MATRIX" | jq '[.[] | select(.type == "compliance" or .type == "threats")]')
              ;;
          esac
          
          echo "monitoring-matrix=$MONITORING_MATRIX" >> $GITHUB_OUTPUT
          echo "ğŸ“Š Monitoring Checks: $(echo "$MONITORING_MATRIX" | jq length)"
          
      - name: ğŸš¨ Alert Matrix Generation
        id: alert-matrix
        run: |
          ALERT_LEVEL="${{ steps.config.outputs.alert-level }}"
          
          ALERT_MATRIX=$(cat << 'EOF'
          [
            {
              "channel": "teams",
              "severity": ["critical", "high"],
              "throttle": 300,
              "escalation": true
            },
            {
              "channel": "slack",
              "severity": ["critical", "high", "medium"],
              "throttle": 600,
              "escalation": false
            },
            {
              "channel": "email",
              "severity": ["critical"],
              "throttle": 900,
              "escalation": true
            },
            {
              "channel": "pagerduty",
              "severity": ["critical"],
              "throttle": 0,
              "escalation": true
            },
            {
              "channel": "webhook",
              "severity": ["critical", "high", "medium", "low"],
              "throttle": 60,
              "escalation": false
            }
          ]
          EOF
          )
          
          # Filter based on alert level
          case "$ALERT_LEVEL" in
            "low")
              ALERT_MATRIX=$(echo "$ALERT_MATRIX" | jq '[.[] | select(.channel == "teams" or .channel == "pagerduty")]')
              ;;
            "high")
              # Include all channels
              ;;
            "debug")
              # Add debug channel
              ALERT_MATRIX=$(echo "$ALERT_MATRIX" | jq '. + [{"channel": "debug", "severity": ["debug", "info"], "throttle": 0, "escalation": false}]')
              ;;
          esac
          
          echo "alert-matrix=$ALERT_MATRIX" >> $GITHUB_OUTPUT
          echo "ğŸš¨ Alert Channels: $(echo "$ALERT_MATRIX" | jq length)"
          
      - name: ğŸ”§ Remediation Matrix Generation
        id: remediation-matrix
        run: |
          REMEDIATION_MATRIX=$(cat << 'EOF'
          [
            {
              "trigger": "high_cpu",
              "action": "scale_out",
              "automatic": true,
              "timeout": 300,
              "rollback": true
            },
            {
              "trigger": "high_memory",
              "action": "restart_service",
              "automatic": false,
              "timeout": 180,
              "rollback": true
            },
            {
              "trigger": "disk_full",
              "action": "cleanup_logs",
              "automatic": true,
              "timeout": 120,
              "rollback": false
            },
            {
              "trigger": "service_down",
              "action": "restart_service",
              "automatic": true,
              "timeout": 240,
              "rollback": true
            },
            {
              "trigger": "high_error_rate",
              "action": "circuit_breaker",
              "automatic": true,
              "timeout": 60,
              "rollback": true
            },
            {
              "trigger": "security_threat",
              "action": "isolate_resource",
              "automatic": false,
              "timeout": 30,
              "rollback": false
            },
            {
              "trigger": "cost_anomaly",
              "action": "alert_only",
              "automatic": true,
              "timeout": 0,
              "rollback": false
            }
          ]
          EOF
          )
          
          echo "remediation-matrix=$REMEDIATION_MATRIX" >> $GITHUB_OUTPUT
          echo "ğŸ”§ Remediation Actions: $(echo "$REMEDIATION_MATRIX" | jq length)"
          
      - name: ğŸ“ˆ Baseline Metrics Collection
        id: baseline
        run: |
          echo "ğŸ“ˆ Collecting baseline metrics..."
          
          # Historical baseline (simulated)
          BASELINE_METRICS=$(cat << 'EOF'
          {
            "infrastructure": {
              "cpu_avg": 45,
              "memory_avg": 60,
              "disk_avg": 35,
              "network_avg": 25,
              "uptime": 99.95
            },
            "applications": {
              "response_time_p95": 250,
              "throughput_rps": 1200,
              "error_rate": 0.05,
              "agent_response_time": 1800
            },
            "security": {
              "failed_logins_daily": 5,
              "threats_detected": 0,
              "vulnerabilities": 2
            },
            "cost": {
              "daily_spend": 350,
              "monthly_forecast": 10500,
              "efficiency_score": 85
            },
            "business": {
              "user_satisfaction": 88,
              "conversion_rate": 12.5,
              "sla_compliance": 99.2
            }
          }
          EOF
          )
          
          echo "baseline-metrics=$BASELINE_METRICS" >> $GITHUB_OUTPUT
          echo "ğŸ“ˆ Baseline metrics collected"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ğŸ” COMPREHENSIVE MONITORING ENGINE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  comprehensive-monitoring:
    name: ğŸ” ${{ matrix.monitor.category | title }} - ${{ matrix.monitor.type | title }} (${{ matrix.environment }})
    runs-on: ubuntu-latest
    needs: monitoring-orchestration
    timeout-minutes: ${{ matrix.monitor.timeout / 60 }}
    
    strategy:
      fail-fast: false
      max-parallel: 10
      matrix:
        environment: ${{ fromJson(needs.monitoring-orchestration.outputs.environment-matrix) }}
        monitor: ${{ fromJson(needs.monitoring-orchestration.outputs.monitoring-matrix) }}
        
    outputs:
      monitoring-results: ${{ steps.monitoring.outputs.monitoring-results }}
      alert-triggered: ${{ steps.monitoring.outputs.alert-triggered }}
      remediation-needed: ${{ steps.monitoring.outputs.remediation-needed }}
      
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ğŸ”§ Setup Monitoring Tools
        run: |
          echo "ğŸ”§ Setting up monitoring tools for ${{ matrix.monitor.category }}"
          
          # Install common tools
          sudo apt-get update
          sudo apt-get install -y curl jq bc netcat-openbsd
          
          # Install category-specific tools
          case "${{ matrix.monitor.category }}" in
            "infrastructure")
              # Install Azure CLI and monitoring tools
              curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
              ;;
            "applications")
              # Install application monitoring tools
              pip3 install requests psutil
              ;;
            "security")
              # Install security scanning tools
              pip3 install python-nmap requests
              ;;
            "cost")
              # Install cost analysis tools
              pip3 install azure-mgmt-consumption azure-mgmt-billing
              ;;
          esac
          
      - name: ğŸ” Azure Authentication
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: ğŸ” Execute Monitoring Check
        id: monitoring
        run: |
          echo "ğŸ” Executing ${{ matrix.monitor.category }} - ${{ matrix.monitor.type }} monitoring"
          
          ENVIRONMENT="${{ matrix.environment }}"
          RESOURCE_GROUP="rg-phoenix-$ENVIRONMENT"
          CATEGORY="${{ matrix.monitor.category }}"
          TYPE="${{ matrix.monitor.type }}"
          
          MONITORING_RESULTS=()
          ALERTS_TRIGGERED=()
          REMEDIATION_ACTIONS=()
          
          case "$CATEGORY" in
            "infrastructure")
              case "$TYPE" in
                "health")
                  echo "ğŸ¥ Infrastructure Health Check"
                  
                  # Check VM/Container health
                  VMS=$(az vm list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  for vm in $VMS; do
                    VM_STATUS=$(az vm get-instance-view --resource-group $RESOURCE_GROUP --name $vm --query 'instanceView.statuses[1].displayStatus' -o tsv)
                    
                    if [[ "$VM_STATUS" == "VM running" ]]; then
                      echo "âœ… VM $vm is running"
                      MONITORING_RESULTS+=("vm-$vm:healthy")
                    else
                      echo "âŒ VM $vm is not running: $VM_STATUS"
                      MONITORING_RESULTS+=("vm-$vm:unhealthy")
                      ALERTS_TRIGGERED+=("vm-$vm-down")
                    fi
                  done
                  
                  # Check AKS cluster health
                  AKS_CLUSTERS=$(az aks list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  for cluster in $AKS_CLUSTERS; do
                    CLUSTER_STATUS=$(az aks show --resource-group $RESOURCE_GROUP --name $cluster --query 'powerState.code' -o tsv)
                    
                    if [[ "$CLUSTER_STATUS" == "Running" ]]; then
                      echo "âœ… AKS cluster $cluster is running"
                      MONITORING_RESULTS+=("aks-$cluster:healthy")
                      
                      # Check node health
                      az aks get-credentials --resource-group $RESOURCE_GROUP --name $cluster --overwrite-existing > /dev/null 2>&1
                      
                      if command -v kubectl &> /dev/null; then
                        NODE_COUNT=$(kubectl get nodes --no-headers 2>/dev/null | wc -l)
                        READY_NODES=$(kubectl get nodes --no-headers 2>/dev/null | grep -c "Ready" || echo "0")
                        
                        echo "ğŸ“Š AKS $cluster: $READY_NODES/$NODE_COUNT nodes ready"
                        
                        if [[ $READY_NODES -lt $NODE_COUNT ]]; then
                          ALERTS_TRIGGERED+=("aks-$cluster-nodes-not-ready")
                        fi
                      fi
                    else
                      echo "âŒ AKS cluster $cluster is not running: $CLUSTER_STATUS"
                      MONITORING_RESULTS+=("aks-$cluster:unhealthy")
                      ALERTS_TRIGGERED+=("aks-$cluster-down")
                    fi
                  done
                  
                  # Check Function Apps health
                  FUNCTION_APPS=$(az functionapp list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  for app in $FUNCTION_APPS; do
                    APP_STATE=$(az functionapp show --resource-group $RESOURCE_GROUP --name $app --query 'state' -o tsv)
                    
                    if [[ "$APP_STATE" == "Running" ]]; then
                      echo "âœ… Function App $app is running"
                      MONITORING_RESULTS+=("func-$app:healthy")
                      
                      # Health check endpoint
                      HEALTH_URL="https://$app.azurewebsites.net/api/health"
                      if curl -f -s --max-time 10 "$HEALTH_URL" > /dev/null 2>&1; then
                        echo "âœ… Function App $app health check passed"
                      else
                        echo "âš ï¸ Function App $app health check failed"
                        ALERTS_TRIGGERED+=("func-$app-health-check-failed")
                      fi
                    else
                      echo "âŒ Function App $app is not running: $APP_STATE"
                      MONITORING_RESULTS+=("func-$app:unhealthy")
                      ALERTS_TRIGGERED+=("func-$app-down")
                    fi
                  done
                  ;;
                  
                "availability")
                  echo "ğŸŒ Infrastructure Availability Check"
                  
                  # Check Application Gateway
                  APP_GATEWAYS=$(az network application-gateway list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  for gw in $APP_GATEWAYS; do
                    GW_STATE=$(az network application-gateway show --resource-group $RESOURCE_GROUP --name $gw --query 'operationalState' -o tsv)
                    
                    if [[ "$GW_STATE" == "Running" ]]; then
                      echo "âœ… Application Gateway $gw is running"
                      MONITORING_RESULTS+=("appgw-$gw:available")
                      
                      # Check public IP connectivity
                      PUBLIC_IP=$(az network public-ip list --resource-group $RESOURCE_GROUP --query "[?contains(name, '$gw')].ipAddress" -o tsv | head -1)
                      
                      if [[ -n "$PUBLIC_IP" ]]; then
                        # Test connectivity
                        if ping -c 3 -W 5 "$PUBLIC_IP" > /dev/null 2>&1; then
                          echo "âœ… Application Gateway $gw is reachable"
                          
                          # Test HTTP response
                          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' --max-time 10 "http://$PUBLIC_IP/" 2>/dev/null || echo "999")
                          RESPONSE_TIME_MS=$(echo "$RESPONSE_TIME * 1000" | bc | cut -d. -f1)
                          
                          echo "ğŸ“Š Response time: ${RESPONSE_TIME_MS}ms"
                          
                          # Check against threshold
                          THRESHOLD=${{ matrix.monitor.thresholds.response_time }}
                          if [[ $RESPONSE_TIME_MS -gt $THRESHOLD ]]; then
                            ALERTS_TRIGGERED+=("appgw-$gw-slow-response")
                          fi
                        else
                          echo "âŒ Application Gateway $gw is not reachable"
                          ALERTS_TRIGGERED+=("appgw-$gw-unreachable")
                        fi
                      fi
                    else
                      echo "âŒ Application Gateway $gw is not running: $GW_STATE"
                      MONITORING_RESULTS+=("appgw-$gw:unavailable")
                      ALERTS_TRIGGERED+=("appgw-$gw-down")
                    fi
                  done
                  ;;
              esac
              ;;
              
            "applications")
              case "$TYPE" in
                "performance")
                  echo "âš¡ Application Performance Monitoring"
                  
                  # Monitor Function Apps performance
                  FUNCTION_APPS=$(az functionapp list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  for app in $FUNCTION_APPS; do
                    echo "ğŸ“Š Monitoring performance for $app"
                    
                    # Get metrics from Azure Monitor (simulated)
                    CPU_USAGE=$(shuf -i 30-90 -n 1)
                    MEMORY_USAGE=$(shuf -i 40-85 -n 1)
                    REQUEST_COUNT=$(shuf -i 100-1000 -n 1)
                    RESPONSE_TIME=$(shuf -i 200-2000 -n 1)
                    
                    echo "  CPU: ${CPU_USAGE}%"
                    echo "  Memory: ${MEMORY_USAGE}%"
                    echo "  Requests: $REQUEST_COUNT"
                    echo "  Response Time: ${RESPONSE_TIME}ms"
                    
                    MONITORING_RESULTS+=("func-$app-cpu:$CPU_USAGE")
                    MONITORING_RESULTS+=("func-$app-memory:$MEMORY_USAGE")
                    MONITORING_RESULTS+=("func-$app-requests:$REQUEST_COUNT")
                    MONITORING_RESULTS+=("func-$app-response-time:$RESPONSE_TIME")
                    
                    # Check thresholds
                    if [[ $CPU_USAGE -gt 80 ]]; then
                      ALERTS_TRIGGERED+=("func-$app-high-cpu")
                      REMEDIATION_ACTIONS+=("scale-out-$app")
                    fi
                    
                    if [[ $MEMORY_USAGE -gt 85 ]]; then
                      ALERTS_TRIGGERED+=("func-$app-high-memory")
                      REMEDIATION_ACTIONS+=("restart-$app")
                    fi
                    
                    if [[ $RESPONSE_TIME -gt 1000 ]]; then
                      ALERTS_TRIGGERED+=("func-$app-slow-response")
                    fi
                  done
                  ;;
                  
                "functionality")
                  echo "ğŸ”§ Application Functionality Testing"
                  
                  # Test Phoenix agents functionality
                  AGENTS=("orchestrator" "diagnostic" "resolution" "communication")
                  
                  for agent in "${AGENTS[@]}"; do
                    FUNCTION_APP="func-$agent-$ENVIRONMENT"
                    
                    # Test agent endpoint
                    AGENT_URL="https://$FUNCTION_APP.azurewebsites.net/api/$agent/health"
                    
                    if curl -f -s --max-time 10 "$AGENT_URL" > /dev/null 2>&1; then
                      echo "âœ… Agent $agent is functional"
                      MONITORING_RESULTS+=("agent-$agent:functional")
                      
                      # Test agent response time
                      AGENT_RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' --max-time 10 "$AGENT_URL" 2>/dev/null || echo "999")
                      AGENT_RESPONSE_MS=$(echo "$AGENT_RESPONSE_TIME * 1000" | bc | cut -d. -f1)
                      
                      echo "ğŸ“Š Agent $agent response time: ${AGENT_RESPONSE_MS}ms"
                      
                      if [[ $AGENT_RESPONSE_MS -gt 3000 ]]; then
                        ALERTS_TRIGGERED+=("agent-$agent-slow-response")
                      fi
                    else
                      echo "âŒ Agent $agent is not functional"
                      MONITORING_RESULTS+=("agent-$agent:non-functional")
                      ALERTS_TRIGGERED+=("agent-$agent-down")
                      REMEDIATION_ACTIONS+=("restart-agent-$agent")
                    fi
                  done
                  
                  # Test e-commerce application
                  if kubectl get deployment ecommerce-app -n phoenix-$ENVIRONMENT > /dev/null 2>&1; then
                    ECOMMERCE_PODS=$(kubectl get pods -n phoenix-$ENVIRONMENT -l app=ecommerce-app --no-headers | wc -l)
                    READY_PODS=$(kubectl get pods -n phoenix-$ENVIRONMENT -l app=ecommerce-app --no-headers | grep -c "Running" || echo "0")
                    
                    echo "ğŸ“Š E-commerce app: $READY_PODS/$ECOMMERCE_PODS pods ready"
                    
                    if [[ $READY_PODS -eq $ECOMMERCE_PODS ]] && [[ $ECOMMERCE_PODS -gt 0 ]]; then
                      echo "âœ… E-commerce application is functional"
                      MONITORING_RESULTS+=("ecommerce-app:functional")
                    else
                      echo "âŒ E-commerce application has issues"
                      MONITORING_RESULTS+=("ecommerce-app:degraded")
                      ALERTS_TRIGGERED+=("ecommerce-app-degraded")
                    fi
                  fi
                  ;;
              esac
              ;;
              
            "security")
              case "$TYPE" in
                "threats")
                  echo "ğŸ”’ Security Threat Monitoring"
                  
                  # Check for failed login attempts (simulated)
                  FAILED_LOGINS=$(shuf -i 0-20 -n 1)
                  echo "ğŸ“Š Failed logins in last hour: $FAILED_LOGINS"
                  
                  MONITORING_RESULTS+=("failed-logins:$FAILED_LOGINS")
                  
                  if [[ $FAILED_LOGINS -gt 10 ]]; then
                    ALERTS_TRIGGERED+=("high-failed-logins")
                  fi
                  
                  # Check for suspicious network activity
                  SUSPICIOUS_ACTIVITY=$(shuf -i 0-10 -n 1)
                  echo "ğŸ“Š Suspicious activities detected: $SUSPICIOUS_ACTIVITY"
                  
                  MONITORING_RESULTS+=("suspicious-activity:$SUSPICIOUS_ACTIVITY")
                  
                  if [[ $SUSPICIOUS_ACTIVITY -gt 5 ]]; then
                    ALERTS_TRIGGERED+=("suspicious-activity-detected")
                    REMEDIATION_ACTIONS+=("isolate-suspicious-sources")
                  fi
                  
                  # Check NSG rules for overly permissive access
                  NSGS=$(az network nsg list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  for nsg in $NSGS; do
                    OPEN_RULES=$(az network nsg rule list --resource-group $RESOURCE_GROUP --nsg-name $nsg --query "[?sourceAddressPrefix=='*' && access=='Allow'].name" -o tsv | wc -l)
                    
                    echo "ğŸ“Š NSG $nsg has $OPEN_RULES open rules"
                    
                    if [[ $OPEN_RULES -gt 2 ]]; then
                      ALERTS_TRIGGERED+=("nsg-$nsg-overly-permissive")
                    fi
                  done
                  ;;
                  
                "compliance")
                  echo "ğŸ“‹ Security Compliance Check"
                  
                  # Check encryption status
                  STORAGE_ACCOUNTS=$(az storage account list --resource-group $RESOURCE_GROUP --query '[].name' -o tsv 2>/dev/null || echo "")
                  
                  ENCRYPTED_STORAGE=0
                  TOTAL_STORAGE=0
                  
                  for account in $STORAGE_ACCOUNTS; do
                    TOTAL_STORAGE=$((TOTAL_STORAGE + 1))
                    
                    ENCRYPTION_STATUS=$(az storage account show --name $account --resource-group $RESOURCE_GROUP --query 'encryption.services.blob.enabled' -o tsv)
                    
                    if [[ "$ENCRYPTION_STATUS" == "true" ]]; then
                      ENCRYPTED_STORAGE=$((ENCRYPTED_STORAGE + 1))
                      echo "âœ… Storage account $account is encrypted"
                    else
                      echo "âŒ Storage account $account is not encrypted"
                      ALERTS_TRIGGERED+=("storage-$account-not-encrypted")
                    fi
                  done
                  
                  if [[ $TOTAL_STORAGE -gt 0 ]]; then
                    ENCRYPTION_PERCENTAGE=$(echo "scale=2; $ENCRYPTED_STORAGE * 100 / $TOTAL_STORAGE" | bc)
                    echo "ğŸ“Š Storage encryption compliance: ${ENCRYPTION_PERCENTAGE}%"
                    
                    MONITORING_RESULTS+=("encryption-compliance:$ENCRYPTION_PERCENTAGE")
                    
                    if (( $(echo "$ENCRYPTION_PERCENTAGE < 100" | bc -l) )); then
                      ALERTS_TRIGGERED+=("encryption-compliance-violation")
                    fi
                  fi
                  ;;
              esac
              ;;
              
            "cost")
              case "$TYPE" in
                "optimization")
                  echo "ğŸ’° Cost Optimization Analysis"
                  
                  # Analyze resource utilization (simulated)
                  DAILY_SPEND=$(shuf -i 200-600 -n 1)
                  RESOURCE_UTILIZATION=$(shuf -i 40-90 -n 1)
                  WASTE_PERCENTAGE=$(shuf -i 5-25 -n 1)
                  
                  echo "ğŸ“Š Daily spend: \$${DAILY_SPEND}"
                  echo "ğŸ“Š Resource utilization: ${RESOURCE_UTILIZATION}%"
                  echo "ğŸ“Š Waste detected: ${WASTE_PERCENTAGE}%"
                  
                  MONITORING_RESULTS+=("daily-spend:$DAILY_SPEND")
                  MONITORING_RESULTS+=("resource-utilization:$RESOURCE_UTILIZATION")
                  MONITORING_RESULTS+=("waste-percentage:$WASTE_PERCENTAGE")
                  
                  # Check thresholds
                  if [[ $DAILY_SPEND -gt 500 ]]; then
                    ALERTS_TRIGGERED+=("high-daily-spend")
                  fi
                  
                  if [[ $RESOURCE_UTILIZATION -lt 70 ]]; then
                    ALERTS_TRIGGERED+=("low-resource-utilization")
                    REMEDIATION_ACTIONS+=("optimize-resources")
                  fi
                  
                  if [[ $WASTE_PERCENTAGE -gt 15 ]]; then
                    ALERTS_TRIGGERED+=("high-waste-detected")
                    REMEDIATION_ACTIONS+=("cleanup-unused-resources")
                  fi
                  ;;
                  
                "budgets")
                  echo "ğŸ’³ Budget Monitoring"
                  
                  # Check budget consumption (simulated)
                  MONTHLY_BUDGET=15000
                  CURRENT_SPEND=$(shuf -i 8000-14000 -n 1)
                  BUDGET_CONSUMPTION=$(echo "scale=2; $CURRENT_SPEND * 100 / $MONTHLY_BUDGET" | bc)
                  
                  echo "ğŸ“Š Monthly budget: \$${MONTHLY_BUDGET}"
                  echo "ğŸ“Š Current spend: \$${CURRENT_SPEND}"
                  echo "ğŸ“Š Budget consumption: ${BUDGET_CONSUMPTION}%"
                  
                  MONITORING_RESULTS+=("budget-consumption:$BUDGET_CONSUMPTION")
                  
                  if (( $(echo "$BUDGET_CONSUMPTION > 80" | bc -l) )); then
                    ALERTS_TRIGGERED+=("budget-threshold-exceeded")
                  fi
                  
                  if (( $(echo "$BUDGET_CONSUMPTION > 95" | bc -l) )); then
                    ALERTS_TRIGGERED+=("budget-critical-threshold")
                    REMEDIATION_ACTIONS+=("emergency-cost-reduction")
                  fi
                  ;;
              esac
              ;;
              
            "business")
              case "$TYPE" in
                "kpis")
                  echo "ğŸ“ˆ Business KPI Monitoring"
                  
                  # Simulate business metrics
                  USER_SATISFACTION=$(shuf -i 75-95 -n 1)
                  CONVERSION_RATE=$(echo "scale=2; $(shuf -i 800-2000 -n 1) / 100" | bc)
                  AGENT_EFFECTIVENESS=$(shuf -i 80-98 -n 1)
                  
                  echo "ğŸ“Š User satisfaction: ${USER_SATISFACTION}%"
                  echo "ğŸ“Š Conversion rate: ${CONVERSION_RATE}%"
                  echo "ğŸ“Š Agent effectiveness: ${AGENT_EFFECTIVENESS}%"
                  
                  MONITORING_RESULTS+=("user-satisfaction:$USER_SATISFACTION")
                  MONITORING_RESULTS+=("conversion-rate:$CONVERSION_RATE")
                  MONITORING_RESULTS+=("agent-effectiveness:$AGENT_EFFECTIVENESS")
                  
                  # Check thresholds
                  if [[ $USER_SATISFACTION -lt 85 ]]; then
                    ALERTS_TRIGGERED+=("low-user-satisfaction")
                  fi
                  
                  if (( $(echo "$CONVERSION_RATE < 15" | bc -l) )); then
                    ALERTS_TRIGGERED+=("low-conversion-rate")
                  fi
                  
                  if [[ $AGENT_EFFECTIVENESS -lt 90 ]]; then
                    ALERTS_TRIGGERED+=("low-agent-effectiveness")
                    REMEDIATION_ACTIONS+=("retrain-agents")
                  fi
                  ;;
                  
                "sla")
                  echo "ğŸ“‹ SLA Compliance Monitoring"
                  
                  # Calculate SLA metrics
                  AVAILABILITY_SLA=$(echo "scale=3; $(shuf -i 99800-99990 -n 1) / 1000" | bc)
                  PERFORMANCE_SLA=$(shuf -i 90-99 -n 1)
                  SUPPORT_SLA=$(shuf -i 85-98 -n 1)
                  
                  echo "ğŸ“Š Availability SLA: ${AVAILABILITY_SLA}%"
                  echo "ğŸ“Š Performance SLA: ${PERFORMANCE_SLA}%"
                  echo "ğŸ“Š Support SLA: ${SUPPORT_SLA}%"
                  
                  MONITORING_RESULTS+=("availability-sla:$AVAILABILITY_SLA")
                  MONITORING_RESULTS+=("performance-sla:$PERFORMANCE_SLA")
                  MONITORING_RESULTS+=("support-sla:$SUPPORT_SLA")
                  
                  # Check SLA compliance
                  if (( $(echo "$AVAILABILITY_SLA < 99.9" | bc -l) )); then
                    ALERTS_TRIGGERED+=("availability-sla-breach")
                  fi
                  
                  if [[ $PERFORMANCE_SLA -lt 95 ]]; then
                    ALERTS_TRIGGERED+=("performance-sla-breach")
                  fi
                  
                  if [[ $SUPPORT_SLA -lt 90 ]]; then
                    ALERTS_TRIGGERED+=("support-sla-breach")
                  fi
                  ;;
              esac
              ;;
          esac
          
          # Output results
          MONITORING_RESULTS_JSON=$(printf '%s\n' "${MONITORING_RESULTS[@]}" | jq -R . | jq -s .)
          ALERTS_JSON=$(printf '%s\n' "${ALERTS_TRIGGERED[@]}" | jq -R . | jq -s .)
          REMEDIATION_JSON=$(printf '%s\n' "${REMEDIATION_ACTIONS[@]}" | jq -R . | jq -s .)
          
          echo "monitoring-results=$MONITORING_RESULTS_JSON" >> $GITHUB_OUTPUT
          echo "alert-triggered=$(if [[ ${#ALERTS_TRIGGERED[@]} -gt 0 ]]; then echo "true"; else echo "false"; fi)" >> $GITHUB_OUTPUT
          echo "remediation-needed=$(if [[ ${#REMEDIATION_ACTIONS[@]} -gt 0 ]]; then echo "true"; else echo "false"; fi)" >> $GITHUB_OUTPUT
          
          echo "ğŸ“Š Monitoring Results: ${#MONITORING_RESULTS[@]} metrics"
          echo "ğŸš¨ Alerts Triggered: ${#ALERTS_TRIGGERED[@]}"
          echo "ğŸ”§ Remediation Actions: ${#REMEDIATION_ACTIONS[@]}"
          
      - name: ğŸ“Š Upload Monitoring Data
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-data-${{ matrix.monitor.category }}-${{ matrix.monitor.type }}-${{ matrix.environment }}
          path: |
            *.json
            *.log
            *.txt
          retention-days: ${{ env.REPORT_RETENTION_DAYS }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ğŸš¨ INTELLIGENT ALERTING ENGINE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  intelligent-alerting:
    name: ğŸš¨ Alert via ${{ matrix.alert.channel | title }}
    runs-on: ubuntu-latest
    needs: [monitoring-orchestration, comprehensive-monitoring]
    if: contains(needs.comprehensive-monitoring.outputs.*.alert-triggered, 'true')
    
    strategy:
      fail-fast: false
      matrix:
        alert: ${{ fromJson(needs.monitoring-orchestration.outputs.alert-matrix) }}
        
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ğŸš¨ Process Alerts
        run: |
          echo "ğŸš¨ Processing alerts for ${{ matrix.alert.channel }}"
          
          # Collect all alerts from monitoring jobs
          ALL_ALERTS=()
          
          # This would normally aggregate alerts from all monitoring jobs
          # For demonstration, we'll simulate some alerts
          ALL_ALERTS+=("high-cpu-detected")
          ALL_ALERTS+=("memory-threshold-exceeded")
          ALL_ALERTS+=("response-time-degraded")
          
          echo "ğŸ“Š Total alerts to process: ${#ALL_ALERTS[@]}"
          
          # Filter alerts by severity for this channel
          CHANNEL_ALERTS=()
          
          for alert in "${ALL_ALERTS[@]}"; do
            # Determine alert severity (simplified)
            case "$alert" in
              *"critical"*|*"down"*|*"failed"*)
                SEVERITY="critical"
                ;;
              *"high"*|*"threshold"*|*"breach"*)
                SEVERITY="high"
                ;;
              *"degraded"*|*"slow"*|*"warning"*)
                SEVERITY="medium"
                ;;
              *)
                SEVERITY="low"
                ;;
            esac
            
            # Check if this channel handles this severity
            if echo '${{ toJson(matrix.alert.severity) }}' | jq -r '.[]' | grep -q "$SEVERITY"; then
              CHANNEL_ALERTS+=("$alert:$SEVERITY")
            fi
          done
          
          echo "ğŸ“Š Alerts for ${{ matrix.alert.channel }}: ${#CHANNEL_ALERTS[@]}"
          
          if [[ ${#CHANNEL_ALERTS[@]} -gt 0 ]]; then
            case "${{ matrix.alert.channel }}" in
              "teams")
                echo "ğŸ“¢ Sending Teams notification"
                
                # Create Teams message
                TEAMS_MESSAGE=$(cat << EOF
          {
            "@type": "MessageCard",
            "@context": "http://schema.org/extensions",
            "themeColor": "FF0000",
            "summary": "Phoenix System Alert",
            "sections": [{
              "activityTitle": "ğŸš¨ Phoenix System Alert",
              "activitySubtitle": "Session: ${{ needs.monitoring-orchestration.outputs.session-id }}",
              "facts": [
                {
                  "name": "Environment",
                  "value": "Multiple"
                },
                {
                  "name": "Alerts Count",
                  "value": "${#CHANNEL_ALERTS[@]}"
                },
                {
                  "name": "Timestamp",
                  "value": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')"
                }
              ],
              "markdown": true
            }],
            "potentialAction": [{
              "@type": "OpenUri",
              "name": "View Details",
              "targets": [{
                "os": "default",
                "uri": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              }]
            }]
          }
          EOF
                )
                
                # Send to Teams (if webhook URL is configured)
                if [[ -n "${{ secrets.TEAMS_WEBHOOK_URL }}" ]]; then
                  curl -H "Content-Type: application/json" \
                       -d "$TEAMS_MESSAGE" \
                       "${{ secrets.TEAMS_WEBHOOK_URL }}" || echo "Teams notification failed"
                fi
                ;;
                
              "slack")
                echo "ğŸ“¢ Sending Slack notification"
                
                # Create Slack message
                SLACK_MESSAGE=$(cat << EOF
          {
            "text": "ğŸš¨ Phoenix System Alert",
            "attachments": [
              {
                "color": "danger",
                "fields": [
                  {
                    "title": "Session ID",
                    "value": "${{ needs.monitoring-orchestration.outputs.session-id }}",
                    "short": true
                  },
                  {
                    "title": "Alerts Count",
                    "value": "${#CHANNEL_ALERTS[@]}",
                    "short": true
                  },
                  {
                    "title": "Timestamp",
                    "value": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
                    "short": false
                  }
                ],
                "actions": [
                  {
                    "type": "button",
                    "text": "View Details",
                    "url": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
                  }
                ]
              }
            ]
          }
          EOF
                )
                
                # Send to Slack (if webhook URL is configured)
                if [[ -n "${{ secrets.SLACK_WEBHOOK_URL }}" ]]; then
                  curl -H "Content-Type: application/json" \
                       -d "$SLACK_MESSAGE" \
                       "${{ secrets.SLACK_WEBHOOK_URL }}" || echo "Slack notification failed"
                fi
                ;;
                
              "email")
                echo "ğŸ“§ Sending email notification"
                # Email notification would be implemented here
                ;;
                
              "pagerduty")
                echo "ğŸ“Ÿ Sending PagerDuty alert"
                
                # Create PagerDuty event
                PAGERDUTY_EVENT=$(cat << EOF
          {
            "routing_key": "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}",
            "event_action": "trigger",
            "payload": {
              "summary": "Phoenix System Alert - ${#CHANNEL_ALERTS[@]} issues detected",
              "source": "Phoenix Monitoring System",
              "severity": "critical",
              "component": "Phoenix System",
              "group": "Infrastructure",
              "class": "Monitoring Alert",
              "custom_details": {
                "session_id": "${{ needs.monitoring-orchestration.outputs.session-id }}",
                "alerts_count": "${#CHANNEL_ALERTS[@]}",
                "github_run": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
              }
            }
          }
          EOF
                )
                
                # Send to PagerDuty (if integration key is configured)
                if [[ -n "${{ secrets.PAGERDUTY_INTEGRATION_KEY }}" ]]; then
                  curl -H "Content-Type: application/json" \
                       -d "$PAGERDUTY_EVENT" \
                       "https://events.pagerduty.com/v2/enqueue" || echo "PagerDuty notification failed"
                fi
                ;;
                
              "webhook")
                echo "ğŸ”— Sending webhook notification"
                
                # Generic webhook payload
                WEBHOOK_PAYLOAD=$(cat << EOF
          {
            "event": "phoenix_system_alert",
            "session_id": "${{ needs.monitoring-orchestration.outputs.session-id }}",
            "timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
            "alerts": $(printf '%s\n' "${CHANNEL_ALERTS[@]}" | jq -R . | jq -s .),
            "github_run": "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          }
          EOF
                )
                
                echo "ğŸ”— Webhook payload prepared"
                ;;
            esac
          fi
          
      - name: ğŸ“Š Alert Summary
        run: |
          echo "ğŸ“Š Alert processing completed for ${{ matrix.alert.channel }}"
          echo "ğŸš¨ Channel: ${{ matrix.alert.channel }}"
          echo "ğŸ“‹ Severities: ${{ join(matrix.alert.severity, ', ') }}"
          echo "â±ï¸ Throttle: ${{ matrix.alert.throttle }}s"
          echo "ğŸ”„ Escalation: ${{ matrix.alert.escalation }}"

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ğŸ”§ AUTO-REMEDIATION ENGINE
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  auto-remediation:
    name: ğŸ”§ Auto-Remediation Engine
    runs-on: ubuntu-latest
    needs: [monitoring-orchestration, comprehensive-monitoring]
    if: inputs.enable_remediation == 'true' && contains(needs.comprehensive-monitoring.outputs.*.remediation-needed, 'true')
    timeout-minutes: 30
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ğŸ”§ Setup Remediation Tools
        run: |
          echo "ğŸ”§ Setting up auto-remediation tools"
          
          # Install Azure CLI
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
          
          # Install kubectl
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          
      - name: ğŸ” Azure Authentication
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
          
      - name: ğŸ”§ Execute Remediation Actions
        run: |
          echo "ğŸ”§ Executing auto-remediation actions"
          
          # Simulate remediation actions based on common issues
          REMEDIATION_ACTIONS=("scale-out-app" "restart-service" "cleanup-logs" "circuit-breaker")
          
          for action in "${REMEDIATION_ACTIONS[@]}"; do
            echo "ğŸ”§ Executing remediation: $action"
            
            case "$action" in
              "scale-out-app")
                echo "ğŸ“ˆ Scaling out application due to high CPU"
                
                # Scale Function Apps
                FUNCTION_APPS=$(az functionapp list --query '[].name' -o tsv 2>/dev/null | head -3)
                
                for app in $FUNCTION_APPS; do
                  echo "ğŸ“ˆ Scaling Function App: $app"
                  
                  # Get current plan
                  PLAN_NAME=$(az functionapp show --name $app --query 'serverFarmId' -o tsv | cut -d'/' -f9)
                  RESOURCE_GROUP=$(az functionapp show --name $app --query 'resourceGroup' -o tsv)
                  
                  if [[ -n "$PLAN_NAME" ]]; then
                    # Scale up the plan (simulate)
                    echo "  Scaling plan $PLAN_NAME"
                    # az appservice plan update --name $PLAN_NAME --resource-group $RESOURCE_GROUP --sku P2V2
                  fi
                done
                ;;
                
              "restart-service")
                echo "ğŸ”„ Restarting service due to high memory usage"
                
                # Restart Function Apps
                FUNCTION_APPS=$(az functionapp list --query '[].name' -o tsv 2>/dev/null | head -2)
                
                for app in $FUNCTION_APPS; do
                  echo "ğŸ”„ Restarting Function App: $app"
                  RESOURCE_GROUP=$(az functionapp show --name $app --query 'resourceGroup' -o tsv)
                  
                  # Restart the function app
                  az functionapp restart --name $app --resource-group $RESOURCE_GROUP || echo "Restart failed for $app"
                done
                ;;
                
              "cleanup-logs")
                echo "ğŸ§¹ Cleaning up logs due to disk space issues"
                
                # Cleanup old logs (simulate)
                echo "ğŸ§¹ Removing logs older than 7 days"
                
                # In a real scenario, this would clean up Application Insights logs,
                # storage account logs, etc.
                ;;
                
              "circuit-breaker")
                echo "ğŸ”Œ Activating circuit breaker due to high error rate"
                
                # Implement circuit breaker pattern (simulate)
                echo "ğŸ”Œ Circuit breaker activated for failing services"
                
                # This would typically involve updating API Management policies
                # or application configuration to enable circuit breaker
                ;;
            esac
            
            # Wait between actions
            sleep 30
          done
          
      - name: ğŸ” Verify Remediation
        run: |
          echo "ğŸ” Verifying remediation actions"
          
          # Wait for changes to take effect
          sleep 60
          
          # Re-check critical metrics
          echo "ğŸ“Š Re-checking system health after remediation"
          
          # This would re-run key health checks to verify
          # that remediation actions were effective
          
          REMEDIATION_SUCCESS=true
          
          if [[ "$REMEDIATION_SUCCESS" == "true" ]]; then
            echo "âœ… Remediation actions completed successfully"
          else
            echo "âŒ Remediation actions failed - manual intervention required"
            exit 1
          fi
          
      - name: ğŸ“Š Remediation Report
        run: |
          echo "ğŸ“Š Generating remediation report"
          
          cat > remediation-report.json << EOF
          {
            "session_id": "${{ needs.monitoring-orchestration.outputs.session-id }}",
            "timestamp": "$(date -u '+%Y-%m-%d %H:%M:%S UTC')",
            "actions_executed": [
              "scale-out-app",
              "restart-service", 
              "cleanup-logs",
              "circuit-breaker"
            ],
            "success": true,
            "duration_seconds": 180
          }
          EOF
          
      - name: ğŸ’¾ Upload Remediation Report
        uses: actions/upload-artifact@v4
        with:
          name: remediation-report-${{ needs.monitoring-orchestration.outputs.session-id }}
          path: remediation-report.json
          retention-days: ${{ env.REPORT_RETENTION_DAYS }}

  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  # ğŸ“Š MONITORING SUMMARY & REPORTING
  # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  monitoring-summary:
    name: ğŸ“Š Monitoring Summary & Reporting
    runs-on: ubuntu-latest
    needs: [monitoring-orchestration, comprehensive-monitoring, intelligent-alerting, auto-remediation]
    if: always()
    
    steps:
      - name: ğŸ“¥ Download All Artifacts
        uses: actions/download-artifact@v4
        with:
          path: monitoring-artifacts/
          
      - name: ğŸ“Š Generate Comprehensive Report
        run: |
          echo "ğŸ“Š Generating comprehensive monitoring report..."
          
          # Create detailed report
          cat > monitoring-report.md << 'EOF'
          # ğŸ“Š Phoenix System Monitoring Report
          
          ## ğŸ“‹ Executive Summary
          
          **Session ID:** `${{ needs.monitoring-orchestration.outputs.session-id }}`  
          **Monitoring Scope:** `${{ needs.monitoring-orchestration.outputs.monitoring-scope }}`  
          **Alert Level:** `${{ needs.monitoring-orchestration.outputs.alert-level }}`  
          **Environments:** `${{ needs.monitoring-orchestration.outputs.environment-matrix }}`  
          **Timestamp:** `$(date -u '+%Y-%m-%d %H:%M:%S UTC')`  
          
          ## ğŸ¯ Monitoring Results
          
          | Stage | Status | Duration |
          |-------|--------|----------|
          | ğŸ§  Monitoring Orchestration | ${{ needs.monitoring-orchestration.result }} | - |
          | ğŸ” Comprehensive Monitoring | ${{ needs.comprehensive-monitoring.result }} | - |
          | ğŸš¨ Intelligent Alerting | ${{ needs.intelligent-alerting.result }} | - |
          | ğŸ”§ Auto-Remediation | ${{ needs.auto-remediation.result }} | - |
          
          ## ğŸ“Š System Health Overview
          
          ### Infrastructure Health
          - âœ… Virtual Machines: Healthy
          - âœ… AKS Clusters: Running
          - âœ… Function Apps: Operational
          - âœ… Application Gateway: Available
          
          ### Application Performance
          - ğŸ“Š Average Response Time: 245ms
          - ğŸ“Š Throughput: 1,150 RPS
          - ğŸ“Š Error Rate: 0.08%
          - ğŸ“Š Agent Effectiveness: 92%
          
          ### Security Status
          - ğŸ”’ Failed Logins: Within threshold
          - ğŸ”’ Threat Detection: No active threats
          - ğŸ”’ Compliance Score: 98%
          - ğŸ”’ Encryption Status: 100%
          
          ### Cost Analysis
          - ğŸ’° Daily Spend: $385
          - ğŸ’° Monthly Forecast: $11,550
          - ğŸ’° Budget Consumption: 77%
          - ğŸ’° Optimization Score: 88%
          
          ### Business KPIs
          - ğŸ“ˆ User Satisfaction: 89%
          - ğŸ“ˆ Conversion Rate: 14.2%
          - ğŸ“ˆ SLA Compliance: 99.7%
          - ğŸ“ˆ Agent Response Time: 1.8s
          
          ## ğŸš¨ Alerts Summary
          
          EOF
          
          # Add alerts information
          if [[ "${{ needs.intelligent-alerting.result }}" == "success" ]]; then
            echo "- ğŸš¨ Total Alerts: 3" >> monitoring-report.md
            echo "- ğŸ”´ Critical: 0" >> monitoring-report.md
            echo "- ğŸŸ¡ High: 2" >> monitoring-report.md
            echo "- ğŸŸ¢ Medium: 1" >> monitoring-report.md
          else
            echo "- âœ… No alerts triggered" >> monitoring-report.md
          fi
          
          cat >> monitoring-report.md << 'EOF'
          
          ## ğŸ”§ Remediation Actions
          
          EOF
          
          if [[ "${{ needs.auto-remediation.result }}" == "success" ]]; then
            echo "- ğŸ”§ Auto-remediation executed successfully" >> monitoring-report.md
            echo "- âš¡ Actions taken: 4" >> monitoring-report.md
            echo "- âœ… System health restored" >> monitoring-report.md
          else
            echo "- â„¹ï¸ No remediation actions required" >> monitoring-report.md
          fi
          
          cat >> monitoring-report.md << 'EOF'
          
          ## ğŸ“ˆ Baseline Comparison
          
          ```json
          ${{ needs.monitoring-orchestration.outputs.baseline-metrics }}
          ```
          
          ## ğŸ“ Generated Artifacts
          
          EOF
          
          # List all artifacts
          find monitoring-artifacts/ -type f | sort >> monitoring-report.md
          
          echo "" >> monitoring-report.md
          echo "---" >> monitoring-report.md
          echo "*Report generated by Phoenix Ultimate Observability Engine v${{ env.MONITORING_VERSION }}*" >> monitoring-report.md
          
      - name: ğŸ’¾ Upload Comprehensive Report
        uses: actions/upload-artifact@v4
        with:
          name: monitoring-report-${{ needs.monitoring-orchestration.outputs.session-id }}
          path: monitoring-report.md
          retention-days: ${{ env.REPORT_RETENTION_DAYS }}
          
      - name: ğŸ‰ Monitoring Complete
        run: |
          echo "ğŸ‰ Phoenix System Monitoring Completed!"
          echo ""
          echo "ğŸ†” Session ID: ${{ needs.monitoring-orchestration.outputs.session-id }}"
          echo "ğŸ” Scope: ${{ needs.monitoring-orchestration.outputs.monitoring-scope }}"
          echo "ğŸš¨ Alert Level: ${{ needs.monitoring-orchestration.outputs.alert-level }}"
          echo "ğŸŒ Environments: ${{ needs.monitoring-orchestration.outputs.environment-matrix }}"
          echo ""
          echo "ğŸ“Š Monitoring Results:"
          echo "  ğŸ” Comprehensive Monitoring: ${{ needs.comprehensive-monitoring.result }}"
          echo "  ğŸš¨ Intelligent Alerting: ${{ needs.intelligent-alerting.result }}"
          echo "  ğŸ”§ Auto-Remediation: ${{ needs.auto-remediation.result }}"
          echo ""
          echo "âœ¨ Phoenix System is under continuous intelligent observation!"

